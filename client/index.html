<!DOCTYPE HTML>
<html>
<head>
    <title>pixi.js example 1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
        }
	canvas {
		margin: auto;
		display: block;
	}
    </style>
    <script src="pixi.dev.js"></script>
</head>
<body>
<script src="https://cdn.socket.io/socket.io-1.2.1.js"></script>
<script>
	var socket = io(); //Get the socket connection to the server

	var players = document.getElementById('players');
 
	// create an new instance of a pixi stage with a black background
	var color = 0x00; //Black background
	var stage = new PIXI.Stage(color); 
 
	// create a renderer instance. width=1000, height = 800
	var screen_width = 1400;
	var screen_height = 800;
	var renderer = PIXI.autoDetectRenderer(screen_width, screen_height);
 
	var sprite_types = {'bullet' : 0, 'invader_1' : 1, 'invader_2' : 2, 'invader_3' : 3, 'invader_4' : 4, 'player':5, 'invader_explode':6};
 
 
	// importing a texture atlas created with texturepacker
	var tileAtlas = ["Resources/sprite.json"];
	// create a new loader
	var loader = new PIXI.AssetLoader(tileAtlas);
	// create an empty container
	var gameContainer = new PIXI.DisplayObjectContainer();
	// add the container to the stage
	stage.addChild(gameContainer);
	// add the renderer view element to the DOM
	document.body.appendChild(renderer.view);
	// use callback
	loader.onComplete = onSpritesLoaded;
	
	//begin load
	loader.load();
	
	var entities = {};
	
	
	//Listen to server's broadcasts
	socket.on('new', function(server_entities){
		//Creates a sprite for all sprites passed in as an array
		for (var id in server_entities)
		{
			createSprite(id, server_entities[id]);
		}
	});
	
	socket.on('update', function(server_entities){
		//Updates the sprites' position for all sprites passed in as an array
		for (var id in server_entities)
		{
			entities[id].position.x = server_entities[id].x;
			entities[id].position.y = server_entities[id].y;
		}
	});
	
	socket.on('delete', function(data){
		gameContainer.removeChild(entities[data[0]]);
		delete entities[data[0]];
	});
	
	socket.on('explode', function(data){
		//Animate explosion
		var sprite = PIXI.Sprite.fromFrame(sprite_types['invader_explode']);
		sprite.scale.x = sprite.scale.y = 0.25;
			
		// place the explosion sprite
		sprite.position.x = data[1].x;
		sprite.position.y = data[1].y;
		
		// add the sprite
		gameContainer.addChild(sprite);
		window.setTimeout(function(){
			//Remove the invader explosion
			gameContainer.removeChild(sprite);
		}, 250);
		
		//Remove the invader
		gameContainer.removeChild(entities[data[0]]);
		delete entities[data[0]];
	});

	var map = {32: false, 37: false, 39: false};
	document.addEventListener("keydown", function(e){
		if (e.keyCode in map) {
			map[e.keyCode] = true;
		}
	}, false);
	document.addEventListener("keyup", function(e){
		if (e.keyCode in map) {
			map[e.keyCode] = false;
		}
	}, false);
	
	function onSpritesLoaded(){
	
		window.setInterval(inputLoop, 60);
		requestAnimFrame(animate);
	}

	function createSprite(id, server_entity)
	{
		var sprite = PIXI.Sprite.fromFrame(sprite_types[server_entity.type]);
		if (server_entity.type.indexOf("invader_") > -1)
		{
			sprite.scale.x  = sprite.scale.y = 0.25;
		}
		else sprite.scale.x  = sprite.scale.y = 0.5;
		
		if (entities[id] === undefined)
		{
			//Add the sprite to the array so that we can move it later
			entities[id] = sprite;
			
			// place the sprite
			sprite.position.x = server_entity.x;
			sprite.position.y = server_entity.y;
			
			// add the sprite
			gameContainer.addChild(sprite);
		}
	}
	
	
	function animate() {
		requestAnimFrame(animate);
		renderer.render(stage);
	}
	
	//Function to limit input bullets or any inputs
	function inputLoop()
	{
		if(map[32]) {
			socket.emit('fire');
		}
		if(map[37]) //move left
		{
			socket.emit('move', 'left');
		}
		if (map[39]) //move right
		{
			socket.emit('move', 'right');
		}
	}
	
     </script>
 
    </body>
</html>
